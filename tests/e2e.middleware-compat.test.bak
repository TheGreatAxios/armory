/**
 * E2E Middleware Compatibility Test Suite
 *
 * Tests each middleware package against both Faremeter and x402 clients
 *
 * Matrix:
 * - middleware-hono + Faremeter client
 * - middleware-hono + x402 client
 * - middleware-express + Faremeter client
 * - middleware-express + x402 client
 * - middleware-elysia + Faremeter client
 * - middleware-elysia + x402 client
 * - middleware-bun + Faremeter client
 * - middleware-bun + x402 client
 */

import { describe, test, expect } from "bun:test";
import { privateKeyToAccount } from "viem/accounts";
import { serve } from "bun";
import { Hono } from "hono";
import express from "express";
import { Elysia, t } from "elysia";
import { wrapFetchWithPaymentFromConfig as wrapFaremeter } from "@faremeter/fetch";
import { createPaymentHandler as createFaremeterHandler } from "@faremeter/payment-evm";
import { wrapFetchWithPaymentFromConfig as wrapX402 } from "@x402/fetch";
import { ExactEvmScheme } from "@x402/evm";
import { acceptPaymentsViaArmory as armoryHonoMiddleware } from "@armory-sh/middleware-hono";
import { paymentMiddleware as armoryExpressMiddleware } from "@armory-sh/middleware-express";
import { createBunMiddleware as armoryBunMiddleware } from "@armory-sh/middleware-bun";

const TEST_PRIVATE_KEY = process.env.TEST_PRIVATE_KEY || "0x00000000000000000000000000000000000000000000000000000000000000001";
const PAY_TO = "0x123456789012345678901234567890";
const AMOUNT = "1000000"; // 1 USDC = 1000000 atomic units
const NETWORK = "base-sepolia";

// Test account
const account = privateKeyToAccount(TEST_PRIVATE_KEY as `0x${string}`);

// Payment config (shared across all middleware)
const PAYMENT_CONFIG = {
  payTo: PAY_TO,
  amount: "1.0", // 1 USDC
  network: NETWORK,
  defaultVersion: 2 as const,
  accept: {
    networks: [NETWORK],
    tokens: ["usdc"],
    facilitators: [{
      url: "https://facilitator.payai.network",
    }],
  }
};

/**
 * Middleware test servers - simple implementations
 */
function createHonoServer(port: number) {
  const app = new Hono();
  app.use("/*", armoryHonoMiddleware(PAYMENT_CONFIG));

  app.get("/api/test", (c) => {
    const payment = c.get("payment");
    return c.json({
      success: true,
      message: "Payment verified",
      middleware: "hono",
      payment: payment ? {
        payerAddress: payment.payerAddress,
        version: payment.version,
      } : null,
    });
  });

  return serve({
    fetch: app.fetch,
    port,
  });
}

function createExpressServer(port: number) {
  const app = express();
  app.use(armoryExpressMiddleware(PAYMENT_CONFIG));

  app.get("/api/test", (req: any, res: any) => {
    const payment = (req as any).payment;
    res.json({
      success: true,
      message: "Payment verified",
      middleware: "express",
      payment: payment ? {
        payerAddress: payment.payerAddress,
        version: payment.version,
      } : null,
    });
  });

  const server = app.listen(port);
  return server;
}

function createElysiaServer(port: number) {
  const app = new Elysia({ t });
  app.use(armoryExpressMiddleware(PAYMENT_CONFIG));

  app.get("/api/test", (c) => {
    const payment = c.get("payment");
    return c.json({
      success: true,
      message: "Payment verified",
      middleware: "elysia",
      payment: payment ? {
        payerAddress: payment.payerAddress,
        version: payment.version,
      } : null,
    });
  });

  return Bun.serve({
    fetch: app.fetch,
    port,
  });
}

function createBunServer(port: number) {
  const middleware = armoryBunMiddleware(PAYMENT_CONFIG);

  return serve({
    port,
    async fetch(req) {
      const url = new URL(req.url);
      const authHeader = req.headers.get("PAYMENT-SIGNATURE") || req.headers.get("X-PAYMENT");

      if (!authHeader) {
        return Response.json({
          error: "Payment required",
          x402Version: 2,
          accepts: [{
            scheme: "exact",
            network: "eip155:84532",
            amount: AMOUNT,
            asset: PAY_TO,
            payTo: PAY_TO,
            maxTimeoutSeconds: 300,
          }],
        }, { status: 402 });
      }

      // Simple validation - in real test would use facilitator
      try {
        const payload = JSON.parse(atob(authHeader));
        if (payload.payload?.authorization?.from) {
          return Response.json({
            success: true,
            message: "Payment verified",
            middleware: "bun",
            payment: {
              payerAddress: payload.payload.authorization.from,
              version: 2,
            },
          });
        }
      } catch {
        return Response.json({
          error: "Invalid payment payload",
          message: "Unrecognized format",
        }, { status: 400 });
      }
    },
  });
}

/**
 * Client wrappers
 */
function createFaremeterClient(baseUrl: string) {
  const wallet = {
    ...account,
    chain: { id: 84532 }, // Base Sepolia
  };

  return wrapFaremeter(fetch, {
    handlers: [createFaremeterHandler(wallet)],
  });
}

function createX402Client(baseUrl: string) {
  return wrapX402(fetch, {
    schemes: [
      {
        network: "eip155:*",
        client: new ExactEvmScheme(account),
      },
    ],
  });
}

/**
 * Test helpers
 */
async function runCompatibilityTest(
  middlewareName: string,
  createServer: (port: number) => any,
  clientName: string,
  createClient: (baseUrl: string) => any,
): Promise<boolean> {
  const port = 8800 + Math.floor(Math.random() * 1000);

  console.log(`\nðŸ§ª Testing: ${middlewareName} middleware + ${clientName} client`);

  try {
    // Start server
    const server = createServer(port);
    await new Promise((resolve) => setTimeout(resolve, 100));

    const baseUrl = `http://localhost:${port}`;

    // Create client
    const client = createClient(baseUrl);

    // Test 1: Payment required response
    console.log("  ðŸ“¨ Step 1: Testing payment-required response...");
    const response1 = await client(`${baseUrl}/api/test`, {
      method: "GET",
    });

    expect(response1.status).toBe(402);

    const paymentRequired = response1.headers.get("PAYMENT-REQUIRED") ||
                          response1.headers.get("X-PAYMENT-REQUIRED");

    expect(paymentRequired).toBeTruthy();

    // Test 2: Parse payment requirements
    console.log("  ðŸ“¨ Step 2: Parsing payment requirements...");
    const acceptHeader = paymentRequired!;
    try {
      const decoded = JSON.parse(atob(acceptHeader));
      expect(decoded.accepts).toBeDefined();
      expect(decoded.accepts?.length).toBeGreaterThan(0);
      console.log(`    âœ… Found ${decoded.accepts?.length} accepted payment schemes`);
    } catch (e) {
      console.log(`    âŒ Failed to parse payment requirements: ${e}`);
      throw e;
    }

    console.log(`  âœ… ${middlewareName} + ${clientName}: PASSED\n`);

    // Cleanup
    if ("stop" in server) {
      (server as any).stop();
    } else if ("close" in server) {
      await (server as any).close();
    }

    return true;
  } catch (error) {
    console.log(`  âŒ ${middlewareName} + ${clientName}: FAILED`);
    console.log(`     Error: ${error}`);
    return false;
  }
}

/**
 * Test matrix
 */
describe("E2E Middleware Compatibility", () => {
  const testCases = [
    {
      middleware: "hono",
      createServer: createHonoServer,
      clients: [
        { name: "faremeter", createClient: createFaremeterClient },
        { name: "x402", createClient: createX402Client },
      ],
    },
    {
      middleware: "express",
      createServer: createExpressServer,
      clients: [
        { name: "faremeter", createClient: createFaremeterClient },
        { name: "x402", createClient: createX402Client },
      ],
    },
    {
      middleware: "elysia",
      createServer: createElysiaServer,
      clients: [
        { name: "faremeter", createClient: createFaremeterClient },
        { name: "x402", createClient: createX402Client },
      ],
    },
    {
      middleware: "bun",
      createServer: createBunServer,
      clients: [
        { name: "faremeter", createClient: createFaremeterClient },
        { name: "x402", createClient: createX402Client },
      ],
    },
    ];

  for (const { middleware, createServer, clients } of testCases) {
    for (const { name: clientName, createClient } of clients) {
      test(`${middleware} middleware + ${clientName} client`, async () => {
        const result = await runCompatibilityTest(
          middleware,
          createServer,
          clientName,
          createClient
        );
        expect(result).toBe(true);
      });
    }
  }
});
